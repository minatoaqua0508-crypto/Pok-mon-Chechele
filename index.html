<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>神奇寶貝切切樂</title>
    <meta name="description" content="神奇寶貝切切樂">
  <meta name="keywords" content="神奇寶貝切切樂,神奇寶貝, 切切樂,寶可夢,">
  <meta name="author" content="黃韋傑學者">
  <meta property="og:title" content="神奇寶貝切切樂">
  <meta property="og:description" content="神奇寶貝">
  <meta property="og:image" content="https://github.com/minatoaqua0508-crypto/Pok-mon-Chechele//images/logo3.jpg">

  <meta property="og:url" content="https://github.com/minatoaqua0508-crypto/Pok-mon-Chechele//index.html">
  <meta property="og:type" content="website">
<meta property="og:site_name" content="神奇寶貝切切樂">
<meta name="robots" content="index, follow">
<link rel="canonical" href="https://github.com/minatoaqua0508-crypto/Pok-mon-Chechele//index.html">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
       * {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Arial', sans-serif;
  background: #f8f2ee;
  overflow: hidden;
  user-select: none;
  height: 100vh;
  display: flex;
  flex-direction: column; /* 上下排列：上方工具列 + 下方遊戲 */
}
.credit {
        position: fixed;         /* 固定在視窗，而不是跟著內容 */
        bottom: 10px;            /* 距離底部 10px */
        right: 10px;             /* 距離右邊 10px */
        font-size: 12px;         /* 字體小一點 */
        color: rgba(0, 0, 0, 0.3); /* 半透明灰色 */
        font-style: italic;      /* 斜體 */
        pointer-events: none;    /* 不影響滑鼠點擊 */
        user-select: none;       /* 不能選取文字 */
    }
.game-container {
  flex: 1; /* 遊戲區域填滿剩餘空間 */
  display: flex;
  width: 100%;
}

.game-area {
  flex: 1;
  position: relative;
  background: linear-gradient(135deg, #B7E0FF 0%, #FFF5CD 100%);/* 背景色 */
  overflow: hidden;
  cursor: crosshair;
  touch-action: none;       /* 讓觸控事件不被捲動吃掉 */
  overscroll-behavior: contain;
}

.score-display {
  position: absolute;
  top: 20px;
  left: 20px;
  font-size: 24px;
  font-weight: bold;
  color: #4A4A4A;
  z-index: 1000;
}

.sidebar {
  position: relative; /* 為遮罩定位 */
  width: 100%;
  min-height: 60px;
  background: url("imags/logo00.jpg") center/cover no-repeat;
  padding: 8px 20px;
  display: flex;
  align-items: flex-start;
  gap: 30px;
  flex: 0 0 auto;
}

.sidebar::before {
  content: "";
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,.18); /* 遮罩濃淡可調 */
  pointer-events: none;
}
/* 如果用了遮罩，讓內容在遮罩之上 */
.sidebar > * { position: relative; z-index: 1; }

/* title */
.sidebar-section h2 {
  font-size: 40px;
  font-weight: 700;
  margin-bottom: 6px;
  text-align: center;

 
  
}

/* 遊戲標題欄位 */
.sidebar-section.game-title {
  width: 300px;
  min-height: 80px;
  background: linear-gradient(180deg, #BBDCE5 0%, #ECEEDF 100%);/* 背景色 */
  
  border-radius: 8px;
  padding: 35px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  display: flex;
  flex-direction: column;  /* 垂直排列 */
  align-items: center;
  justify-content: flex-start;
  gap: 10px;  /* 標題與按鈕間距 */
}

/* again 按鈕 */
.again-btn {
  padding: 8px 14px;
  border: none;
  border-radius: 5px;
 background: linear-gradient(135deg, #D9C4B0 0%, #CFAB8D 100%); /* 背景色 */
 border: 1px solid #000; /* 外黑框 */
  border-radius: 8px;
  color: black;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.again-btn:hover {
  background: linear-gradient(45deg, #CFAB8D 0%, #D9C4B0 100%); /* 背景色 */
  border-radius: 8px;
  transform: scale(1.05);
}

/* 歷史最高分數 */
.sidebar-section h3 {
  font-size: 20px;
  font-weight: bold;

  background: linear-gradient(180deg, #B9375D 0%,  #D25D5D 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;

  margin-bottom: 8px;
  text-align: center;
  
}

/* 歷史最高分數欄位 */
.sidebar-section.high-score {
  width: 300px;
  min-height: 80px;
   background: linear-gradient(180deg, #CADCAE 0%, #E1E9C9 100%);
  border-radius: 8px;
  padding: 36px;
  display: flex;
  flex-direction: column;  /* 垂直排列 */
  align-items: center;
  justify-content: flex-start;
  gap: 10px; /* 標題與按鈕間距 */
  color: black;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

/* stop 按鈕 */
#pauseBtn {
  padding: 8px 14px;
  border: none;
  border-radius: 5px;
   background: linear-gradient(135deg, #EDA35A 0%, #FEE8D9 100%); /* 背景色 */
   border: 1px solid #000; /* 外黑框 */
  color: black;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.3s ease;
}

#pauseBtn:hover {
 background: linear-gradient(135deg, #FEE8D9 0%, #EDA35A 100%); /* 背景色 */
  transform: scale(1.05);
}

/* .music-player  */
.sidebar-section.fruit-info.music-player {
  /* 保留你 .fruit-info 的背景、padding、圓角、間距等，不覆蓋就沿用 */
  display: flex;
  flex-direction: column;
  gap: 8px; /* 標題與按鈕間距 */
   padding: 48px 60px;
   border-radius: 10px;
}

/* 標題 h4 */
.sidebar-section.fruit-info.music-player h4 {
  font-size: 18px;        /* 比原 20px 低調 */
  font-weight: 800;
  color: #000000;
  margin-bottom: 6px;
  text-align: center;
  line-height: 1.2;
  word-break: break-all;
}

/* 播放器按鈕列 */
.sidebar-section.fruit-info.music-player .player-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 18px;
}

/* 按鈕外觀 */
.sidebar-section.fruit-info.music-player .btn-icon {
  appearance: none;
  border: none;
  outline: none;
  background: linear-gradient(180deg, #BDE3C3 0%, #A3CCDA 100%);
  color: #fff;
  width: 44px;
  height: 44px;
  border-radius: 999px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0,0,0,.25);
  transition: transform .15s ease, background .15s ease, opacity .15s ease;
}

.sidebar-section.fruit-info.music-player .btn-icon.play {
  width: 56px;
  height: 56px; /* 中間鍵較大 */
}

.sidebar-section.fruit-info.music-player .btn-icon:hover { transform: scale(1.06); }
.sidebar-section.fruit-info.music-player .btn-icon:active { transform: scale(0.95); }
.sidebar-section.fruit-info.music-player .player-controls svg { display: block; }

/* 深色容器上更低調：只針對播放器那一格 */
.sidebar-section.fruit-info.music-player {
 background: linear-gradient(180deg, #F5D2D2 0%, #F8F7BA 100%);
}





/* 積分兌換 */
.sidebar-section h5 {
  font-size: 16px;  /* 積分兌換 */
  font-weight: 500;
  color: #01090e;   /* 淡藍色 */
  margin-bottom: 6px;
}

/* 積分兌換欄位調整 */
.sidebar-section.exchange {
  width: 240px;          /* 固定寬度 */
  min-height: 160px;     /* 固定高度 */
  background: linear-gradient(180deg, #BBDCE5 0%, #ECEEDF 100%);/* 背景色 */
  border-radius: 8px;    /* 圓角 */
  padding: 1px;          /* 內距 */
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  gap: 8px;              /* 標題與按鈕間距 */
  color: white;
  padding-bottom: 10px;  /* 保證最後按鈕底下有空間 */
}

/* 🎯 按鈕統一樣式 */
.sidebar-section.exchange button {
  width: 200px;          /* 統一寬度 */
  height: 40px;          /* 統一高度 */
  border: none;
  border-radius: 5px;
  background: linear-gradient(180deg, #59D5E0 0%, #F5DD61 100%);
  border: 1px solid #000; /* 外黑框 */
  color: black;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.3s ease;
}

/* 🎯 按鈕 hover 效果 */
.sidebar-section.exchange button:hover:enabled {
  background: linear-gradient(180deg,#F5DD61 0%, #59D5E0 100%);
  transform: scale(1.05);
}

/* 🎯 停用狀態保持原程式機制 */
.sidebar-section.exchange button:disabled {
  background: #888;      /* 灰色 (保留原機制) */
  cursor: not-allowed;
  transform: none;
}

/* 先把頁面底色統一為咖啡色，避免任何地方露白 */
html, body { background:#D2B48C !important; }

.fruit-img[src*="roc1.jpg"],
.fruit-img[src*="roc2.png"],
.fruit-img[src*="roc3.webp"],
.fruit-img[src*="roc4.png"]
 {
  width: 100px;
  height: 100px;
  border-radius: 20px;
  object-fit: cover;     /* ✅ 保持比例填滿，不會變形 */
}
/* 桌機預設：所有水果圖片都是 100x100 */

.fruit-img[src*="logo1.png"],
.fruit-img[src*="logo2.jpg"],
.fruit-img[src*="logo3.jpg"],


.fruit-img[src*="logo4.png"],
.fruit-img[src*="logo5.png"],
.fruit-img[src*="logo6.png"],
.fruit-img[src*="logo7.png"],
.fruit-img[src*="logo8.png"],
.fruit-img[src*="logo9.png"],
.fruit-img[src*="logo10.png"],
.fruit-img[src*="logo11.png"],
.fruit-img[src*="logo12.png"],
.fruit-img[src*="logo13.png"],
.fruit-img[src*="logo14.png"],
.fruit-img[src*="logo15.png"],
.fruit-img[src*="logo16.png"],
.fruit-img[src*="logo17.png"],
.fruit-img[src*="logo18.png"],
.fruit-img[src*="logo19.png"],
.fruit-img[src*="logo20.png"],
.fruit-img[src*="logo21.png"]
 {
  width: 100px;
  height: 100px;
  border-radius: 100px;   /* ✅ 加上圓角設計 */
  object-fit: cover;     /* ✅ 保持比例填滿，不會變形 */
}


/* 手機版（寬度 ≤390px）：縮小水果圖片 */
@media (max-width: 450px) {

.fruit-img[src*="logo1.png"],
.fruit-img[src*="logo2.jpg"],
.fruit-img[src*="logo3.jpg"],

  
 .fruit-img[src*="logo4.png"],
.fruit-img[src*="logo5.png"],
.fruit-img[src*="logo6.png"],
.fruit-img[src*="logo7.png"],
.fruit-img[src*="logo8.png"],
.fruit-img[src*="logo9.png"],
.fruit-img[src*="logo10.png"],
.fruit-img[src*="logo11.png"],
.fruit-img[src*="logo12.png"],
.fruit-img[src*="logo13.png"],
.fruit-img[src*="logo14.png"],
.fruit-img[src*="logo15.png"],
.fruit-img[src*="logo16.png"],
.fruit-img[src*="logo17.png"],
.fruit-img[src*="logo18.png"],
.fruit-img[src*="logo19.png"],
.fruit-img[src*="logo20.png"],
.fruit-img[src*="logo21.png"]
{
    width: 50px;   /* 縮小尺寸 */
    height: 50px;
    border-radius: 100px;   /* ✅ 小螢幕縮小，但仍保留圓角 */
    object-fit: cover;
  }
 .fruit-img[src*="roc1.jpg"],
.fruit-img[src*="roc2.png"],
.fruit-img[src*="roc3.webp"],
.fruit-img[src*="roc4.png"]
 {
  width: 50px;
  height: 50px;
  border-radius: 10px;
  object-fit: cover;     /* ✅ 保持比例填滿，不會變形 */
}
}


        .fruit {
            position: absolute;
            font-size: 40px;
            z-index: 100;
            transition: all 0.1s ease;
        }

        .bomb {
            position: absolute;
            font-size: 40px;
            z-index: 100;
        }

        .slice-line {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            border-radius: 2px;
            pointer-events: none;
            z-index: 50;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
        }

        @keyframes sliceEffect {
            0% { 
                transform: scale(1) rotate(0deg); 
                opacity: 1; 
            }
            50% { 
                transform: scale(1.2) rotate(180deg); 
                opacity: 0.7; 
            }
            100% { 
                transform: scale(0.8) rotate(360deg); 
                opacity: 0; 
            }
        }

        .sliced {
            animation: sliceEffect 0.8s ease-out forwards;
        }

        .special-fruit {
            position: absolute;
            font-size: 60px;
            z-index: 90;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
             width: 60px; height: 60px;  /* 沒有就補上；有動態尺寸也可 */
  touch-action: none;         /* 元件本身也停用預設手勢 */
        }

        .special-fruit:hover {
            transform: scale(1.1);
            filter: brightness(1.2);
        }

        .special-fruit:active {
            transform: scale(0.95);
        }

        @keyframes touchReaction {
            0% { transform: scale(1); }
            50% { transform: scale(1.3) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        .special-fruit.touched {
            animation: touchReaction 0.5s ease-out;
        }

        

        
.special-fruit img {
  width: 70px;
  height: 70px;
  object-fit: contain;
}
.special-fruit, .special-red {
  position: absolute;
  cursor: grab;
}
/* special-red 與 special-fruit 一樣的互動/動畫效果 */
.special-red {
  position: absolute;
  z-index: 90;
  width: 60px;
  height: 60px;
  cursor: grab;                        /* 被你前面的合併選擇器覆蓋時，這段需放後面 */
  transition: transform .3s ease, filter .3s ease;
  user-select: none;
  touch-action: none;
  will-change: transform, filter;
}

.special-red:hover {
  transform: scale(1.1);
  filter: brightness(1.2);
}

.special-red:active {
  transform: scale(0.95);
}

/* 套用與 special-fruit 相同的動畫 */
.special-red.touched {
  animation: touchReaction 0.5s ease-out;
}

/* 圖片尺寸與行為（目前你的 fruit 是 70x70）*/
.special-red img {
  width: 70px;
  height: 70px;
  object-fit: contain;
  -webkit-user-drag: none;
  pointer-events: none;
}
             
        

        

        @media (max-width: 768px) {
            .sidebar {
                width: 200px;
                margin-right: 10px;
                padding: 15px;
            }
            
            .fruit, .bomb {
                font-size: 35px;
            }
            
            .score-display {
                font-size: 20px;
            }
        }
        
:root{
  --drawer-handle: 36px; /* 收納時的保留高度(小橫條高度) */
}

/* ▶ 預設：右上角 */
.drawer-toggle{
  position: absolute;
  top: 8px;
  right: 10px;         /* ← 右上 */
  left: auto;
 width: 40px;         /* 28 → 40 */
  height: 40px;        /* 28 → 40 */
  line-height: 40px;   /* 讓字垂直置中 */
  font-size: 20px;     /* 16 → 20，箭頭更大 */
  border: 0;
  border-radius: 50%;
  background: #333;
  color: #fff;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0,0,0,.25);
  transition: transform .25s ease, background .25s ease;
  z-index: 10;         /* 蓋過面板內其他元素 */
}
.drawer-toggle:hover{ transform: scale(1.06); }

/* 讓 sidebar 支援高度動畫 */
.sidebar{
  position: relative;
  transition: height .25s ease, padding .25s ease, background .25s ease, box-shadow .25s ease;
}

/* ▶ 收納：整個 sidebar 收起 */
body.drawer-collapsed .sidebar{
  height: 0;
  min-height: 0;
  padding: 0;
  border: 0;
  box-shadow: none;
  background: transparent;
  overflow: hidden;
}

/* ▶ 收納時：切換鍵固定右上角（不受 sidebar 影響） */
body.drawer-collapsed .drawer-toggle{
  position: fixed;
  top: max(10px, env(safe-area-inset-top));
  right: max(10px, env(safe-area-inset-right));  /* ← 右上 */
  left: auto;
   width: 44px;         /* 32 → 44 */
  height: 44px;        /* 32 → 44 */
  line-height: 44px;
  font-size: 22px;     /* 符號更清楚 */
  border: 0;
  border-radius: 50%;
  background: #222;
  color: #fff;
  z-index: 1002;  /* 蓋在遊戲區上方 */
  box-shadow: 0 2px 6px rgba(0,0,0,.25);
}

/* ▶ 小螢幕微調（避免貼邊/瀏海） */
@media (max-width: 390px){
  .drawer-toggle{
    top: 6px;
    right: max(8px, env(safe-area-inset-right));
    left: auto;
  }
}

/* ====== 450px 以下：工具列 full-bleed + 不被擠壓 ====== */
@media (max-width: 450px){

  /* 直排：工具列在上、遊戲在下 */
  .game-container{
    display:flex;
    flex-direction:column;
  }
  .game-container > .sidebar{ order:1; }
  .game-container > .game-area{ order:2; }

  /* 工具列改成 2 欄 Grid + Full-Bleed */
  .sidebar{
    display:grid !important;
    grid-template-columns: 1fr 1fr;
    grid-template-areas:
      "game-title fruit-info"
      "high-score  exchange";
    gap:12px;

    /* full-bleed 覆蓋左右白邊 */
    width:100vw;
    margin-left: calc(50% - 50vw);
    margin-right:calc(50% - 50vw);
    padding:10px 12px;
    box-sizing:border-box;

    /* 安全區 */
    padding-left:  max(12px, env(safe-area-inset-left));
    padding-right: max(12px, env(safe-area-inset-right));
  }
  @supports (width: 100svw){
    .sidebar{
      width:100svw;
      margin-left: calc(50% - 50svw);
      margin-right:calc(50% - 50svw);
    }
  }

  /* 避免 full-bleed 造成水平卷軸 */
  html, body{ overflow-x:hidden !important; }

  /* 指定四卡片對應位置 */
  .sidebar .game-title, .sidebar-section.game-title{ grid-area: game-title; }
  .sidebar .fruit-info, .sidebar-section.fruit-info{ grid-area: fruit-info; }
  .sidebar .high-score, .sidebar-section.high-score{ grid-area: high-score; }
  .sidebar .exchange,  .sidebar-section.exchange { grid-area: exchange; }

  /* 🔧 關鍵：徹底解除桌機的固定寬高，允許在 Grid 內縮放 */
  .sidebar-section,
  .sidebar .game-title,
  .sidebar .high-score,
  .sidebar .exchange,
  .sidebar .fruit-info,
  .sidebar-section.game-title,
  .sidebar-section.high-score,
  .sidebar-section.exchange,
  .sidebar-section.fruit-info{
    width: 100% !important;
    max-width: none !important;
    min-width: 0 !important;
    min-height: auto !important;
    padding: 10px 12px !important;
    border-radius: 6px;
    box-shadow: 0 2px 6px rgba(0,0,0,.15);
    justify-self: stretch !important;
  }

.sidebar-section.game-title{
    min-height: auto !important;     /* 高度自適應 */
    padding: 19px !important;        /* 內距縮小 */
    font-size: 14px !important;      /* 標題字縮小 */
    gap: 6px !important;             /* 內容間距縮小 */
  }

  .sidebar-section.fruit-info.music-player h4 {
  font-size: 15px;        /* 比原 20px 低調 */
  
}


  .sidebar-section.high-score{
    min-height: auto !important;     /* 高度自適應 */
    padding: 39px !important;        /* 內距縮小 */
    font-size: 14px !important;      /* 標題字縮小 */
    gap: 6px !important;             /* 內容間距縮小 */
  }


  /* 任何直接子元素最小寬度歸零，避免內容把格子撐爆 */
  .sidebar > *{ min-width:0 !important; }

  

  /* 內容微調防擠爆 */
  .sidebar-section h2{ font-size:16px; margin-bottom:4px; }
  .sidebar-section h3{ font-size:14px; margin-bottom:12px; }
  .sidebar-section h4{ font-size:15px; margin-bottom:4px; }
  .sidebar-section h5{ font-size:14px; margin-bottom:4px; }

  .sidebar-section.fruit-info{ gap:6px; }
  .sidebar-section.fruit-info .fruit{
    padding:1px 8px;
    font-size:13px;
    line-height:1.35;
  }

  /* 按鈕在小螢幕拉滿寬 */
  .again-btn,
  #pauseBtn,
  .sidebar-section.exchange button{
    width:100% !important;
    height:36px;
    font-size:11px;
  }

  /* Drawer 切換鍵（若有）避免貼邊/瀏海 */
  .drawer-toggle{
    top:6px;
    right:max(8px, env(safe-area-inset-right));
  }
  .credit {
        position: fixed;         /* 固定在視窗，而不是跟著內容 */
        bottom: 10px;            /* 距離底部 10px */
        right: 10px;             /* 距離右邊 10px */
        font-size: 8px;         /* 字體小一點 */
        color: rgba(0, 0, 0, 0.3); /* 半透明灰色 */
        font-style: italic;      /* 斜體 */
        pointer-events: none;    /* 不影響滑鼠點擊 */
        user-select: none;       /* 不能選取文字 */
    }
}



    </style>
</head>
<body>
    <!-- 上方工具列 -->
    <div class="sidebar">
        <button class="drawer-toggle" aria-expanded="true" onclick="toggleDrawer(this)">⬆</button>
        <!-- 遊戲標題 + Again -->
        <div class="sidebar-section game-title">
    <h2>《神奇寶貝》</h2>
    <button class="again-btn" onclick="restartGame()">again (重新)</button>
</div>

<!-- 歷史分數 + Stop -->
<div class="sidebar-section high-score">
    <h3>歷史最高分數</h3>
    <div id="highScore">0</div>
    <button id="pauseBtn" onclick="togglePause()">stop (暫停)</button>
</div>

<!-- 撥放器 -->
        <div class="sidebar-section fruit-info music-player">
  <h4 id="trackTitle">歌名顯示區</h4>

  <div class="player-controls">
    <button class="btn-icon" id="btnPrev" aria-label="上一首" title="上一首">
      <!-- ⏮ -->
      <svg viewBox="0 0 24 24" width="28" height="28"><path fill="currentColor" d="M6 5h2v14H6V5zm3.5 7L20 19V5L9.5 12z"/></svg>
    </button>

    <button class="btn-icon play" id="btnPlay" aria-label="播放/暫停" title="播放/暫停">
      <!-- ⏯ 初始顯示「播放」圖示 -->
      <svg id="iconPlay" viewBox="0 0 24 24" width="28" height="28"><path fill="currentColor" d="M8 5v14l11-7z"/></svg>
      <svg id="iconPause" viewBox="0 0 24 24" width="28" height="28" style="display:none"><path fill="currentColor" d="M6 5h4v14H6V5zm8 0h4v14h-4V5z"/></svg>
    </button>

    <button class="btn-icon" id="btnNext" aria-label="下一首" title="下一首">
      <!-- ⏭ -->
      <svg viewBox="0 0 24 24" width="28" height="28"><path fill="currentColor" d="M18 5h-2v14h2V5zM14.5 12L4 19V5l10.5 7z"/></svg>
    </button>
  </div>

  <audio id="audioPlayer" preload="metadata"></audio>
</div>

        <!-- 積分兌換 (垂直排列) -->
        <div class="sidebar-section exchange">
            <h5>積分兌換</h5>
            <button onclick="spawnSpecialFruit()" id="specialBtn" disabled>
                10 Point → 普通圖片  (6種)
            </button>
            <button onclick="changeBackgroundRandomBlue()" id="blueBtn" disabled>
                20 Point → 換背景  (12種)
            </button>
            <button onclick="spawnRedEffect()" id="redBtn" disabled>
                50 Point → 高級圖片  (7種)
            </button> 
        </div>
    </div>

    <!-- 下方遊戲區域 -->
    <div class="game-container">
        <div class="game-area" id="gameArea">
            <div class="score-display">Point: <span id="score">0</span></div>
        </div>
    </div>


    <script>
        let gameArea = document.getElementById('gameArea');
        let scoreElement = document.getElementById('score');
        let highScoreElement = document.getElementById('highScore');
        let pauseBtn = document.getElementById('pauseBtn');
        
        let score = 0;
        let highScore = localStorage.getItem('fruitNinjaHighScore') || 0;
        let sessionHighScore = 0; // 本局遊戲的最高分數
        let isPaused = false;
        let fruits = [];
        let specialFruits = [];
        let sliceLines = [];
        
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        
       const fruitImages = [
        'imags/logo1.png', 
       
        'imags/logo4.png',
        'imags/logo5.png',
        'imags/logo6.png',
        'imags/logo7.png',
        'imags/logo8.png',
        'imags/logo9.png',
        'imags/logo10.png',
        'imags/logo11.png',
        'imags/logo12.png',
        'imags/logo13.png',
        'imags/logo14.png',
        'imags/logo15.png',
        'imags/logo16.png',
        'imags/logo17.png',
        'imags/logo18.png',
        'imags/logo19.png',
        'imags/logo20.png',
        'imags/logo21.png',
    ];


const bombImages = [
    'imags/roc1.jpg',
    'imags/roc2.png',
    'imags/roc4.png' ];




const slicedImages = {
    'imags/roc1.jpg': 'imags/roc3.webp',
    'imags/roc2.png': 'imags/roc3.webp',
    'imags/roc4.png': 'imags/roc3.webp',


    'imags/logo1.png': 'imags/logo3.jpg',
   
    'imags/logo4.png': 'imags/logo3.jpg',
    'imags/logo5.png': 'imags/logo3.jpg',
    'imags/logo6.png': 'imags/logo3.jpg',
    'imags/logo7.png': 'imags/logo3.jpg',
    'imags/logo8.png': 'imags/logo3.jpg',
    'imags/logo9.png': 'imags/logo3.jpg',
    'imags/logo10.png': 'imags/logo3.jpg',
    'imags/logo11.png': 'imags/logo3.jpg',
    'imags/logo12.png': 'imags/logo3.jpg',
    'imags/logo13.png': 'imags/logo3.jpg',
    'imags/logo14.png': 'imags/logo3.jpg',
    'imags/logo15.png': 'imags/logo3.jpg',
    'imags/logo16.png': 'imags/logo3.jpg',
    'imags/logo17.png': 'imags/logo3.jpg',
    'imags/logo18.png': 'imags/logo3.jpg',
    'imags/logo19.png': 'imags/logo3.jpg',
    'imags/logo20.png': 'imags/logo3.jpg',
    'imags/logo21.png': 'imags/logo3.jpg',
};
        // 初始化
        highScoreElement.textContent = highScore;
        sessionHighScore = 0; // 初始化本局最高分數
        
        // 生成水果和炸彈
function spawnFruit() {
    if (isPaused) return;

    // 限制場上同時最多 8 個水果
    if (fruits.length >= 2) return;

    const isBomb = Math.random() < 0.2;
    const imgSrc = isBomb 
        ? bombImages[Math.floor(Math.random() * bombImages.length)] 
        : fruitImages[Math.floor(Math.random() * fruitImages.length)];

    const fruit = document.createElement('div');
    fruit.className = isBomb ? 'bomb' : 'fruit';
    fruit.dataset.type = isBomb ? 'bomb' : 'fruit';
    fruit.dataset.src = imgSrc;

    // 加圖片
    const img = document.createElement('img');
    img.src = imgSrc;
    img.className = 'fruit-img';
    fruit.appendChild(img);

    // 從螢幕四邊隨機拋出
    const side = Math.floor(Math.random() * 4);
    let startX, startY, targetX, targetY;

    switch(side) {
        case 0: // 左邊
            startX = -50;
            startY = Math.random() * window.innerHeight;
            targetX = window.innerWidth + 50;
            targetY = Math.random() * window.innerHeight;
            break;
        case 1: // 右邊
            startX = window.innerWidth + 50;
            startY = Math.random() * window.innerHeight;
            targetX = -50;
            targetY = Math.random() * window.innerHeight;
            break;
        case 2: // 上邊
            startX = Math.random() * window.innerWidth;
            startY = -50;
            targetX = Math.random() * window.innerWidth;
            targetY = window.innerHeight + 50;
            break;
        case 3: // 下邊
            startX = Math.random() * window.innerWidth;
            startY = window.innerHeight + 50;
            targetX = Math.random() * window.innerWidth;
            targetY = -50;
            break;
    }

    fruit.style.left = startX + 'px';
    fruit.style.top = startY + 'px';

    gameArea.appendChild(fruit);

    fruits.push({
        element: fruit,
        startX,
        startY,
        targetX,
        targetY,
        progress: 0,
        sliced: false
    });
}

// 更新水果位置
function updateFruits() {
    if (isPaused) return;

    // 倒序遍歷，避免 splice 出錯
    for (let i = fruits.length - 1; i >= 0; i--) {
        let fruit = fruits[i];
        if (fruit.sliced) continue;

        fruit.progress += 0.008;

        // 超出範圍 → 移除
        if (fruit.progress >= 1) {
            fruit.element.remove();
            fruits.splice(i, 1);
            continue;
        }

        // 模擬拋物線運動
        const t = fruit.progress;
        const x = fruit.startX + (fruit.targetX - fruit.startX) * t;
        const y = fruit.startY + (fruit.targetY - fruit.startY) * t + Math.sin(t * Math.PI) * -200;

        fruit.element.style.left = x + 'px';
        fruit.element.style.top = y + 'px';
    }
}

        
        // 滑鼠和觸控事件
        function startSlice(e) {
            if (isPaused) return;
            
            isDrawing = true;
            const rect = gameArea.getBoundingClientRect();
            lastX = (e.clientX || e.touches[0].clientX) - rect.left;
            lastY = (e.clientY || e.touches[0].clientY) - rect.top;
        }
        
        function slice(e) {
            if (!isDrawing || isPaused) return;
            
            e.preventDefault();
            const rect = gameArea.getBoundingClientRect();
            const currentX = (e.clientX || e.touches[0].clientX) - rect.left;
            const currentY = (e.clientY || e.touches[0].clientY) - rect.top;
            
            // 創建劃線效果
            const line = document.createElement('div');
            line.className = 'slice-line';
            
            const dx = currentX - lastX;
            const dy = currentY - lastY;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            line.style.left = lastX + 'px';
            line.style.top = lastY + 'px';
            line.style.width = length + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            line.style.transformOrigin = '0 50%';
            
            gameArea.appendChild(line);
            sliceLines.push(line);
            
            // 檢查碰撞
            checkCollision(lastX, lastY, currentX, currentY);
            
            // 清理舊的劃線
            setTimeout(() => {
                if (line.parentNode) {
                    line.remove();
                    const index = sliceLines.indexOf(line);
                    if (index > -1) sliceLines.splice(index, 1);
                }
            }, 200);
            
            lastX = currentX;
            lastY = currentY;
        }
        
        function endSlice() {
            isDrawing = false;
        }
        
        // 碰撞檢測
        function checkCollision(x1, y1, x2, y2) {
            fruits.forEach(fruit => {
                if (fruit.sliced) return;
                
                const rect = fruit.element.getBoundingClientRect();
                const gameRect = gameArea.getBoundingClientRect();
                const fruitX = rect.left - gameRect.left + rect.width / 2;
                const fruitY = rect.top - gameRect.top + rect.height / 2;
                
                // 簡單的線段與點的距離判斷
                const distance = distanceToLine(x1, y1, x2, y2, fruitX, fruitY);
                
                if (distance < 70) { // 碰撞閾值
                    sliceFruit(fruit);
                }
            });
        }
        
        // 計算點到線段的距離
        function distanceToLine(x1, y1, x2, y2, px, py) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length === 0) return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
            
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (length * length)));
            const projectionX = x1 + t * dx;
            const projectionY = y1 + t * dy;
            
            return Math.sqrt((px - projectionX) * (px - projectionX) + (py - projectionY) * (py - projectionY));
        }
        

        // 圖片對應音效
const slicedSounds = {
    'imags/roc1.jpg': 'sounds/roc sound1.mp3',
    'imags/roc2.png': 'sounds/roc sound1.mp3',
    'imags/roc4.png': 'sounds/roc sound1.mp3',


    'imags/logo1.png': 'sounds/sound1.mp3',
    'imags/logo2.jpg': 'sounds/sound2.mp3',
    'imags/logo4.png': 'sounds/sound4.mp3',
    'imags/logo5.png': 'sounds/sound5.mp3',
    'imags/logo6.png': 'sounds/sound6.mp3',
    'imags/logo7.png': 'sounds/sound7.mp3',
    'imags/logo8.png': 'sounds/sound8.mp3',
    'imags/logo9.png': 'sounds/sound9.mp3',
    'imags/logo10.png': 'sounds/sound10.mp3',
    'imags/logo11.png': 'sounds/sound11.mp3',
    'imags/logo12.png': 'sounds/sound12.mp3',
    'imags/logo13.png': 'sounds/sound13.mp3',
    'imags/logo14.png': 'sounds/sound14.mp3',
    'imags/logo15.png': 'sounds/sound15.mp3',
    'imags/logo16.png': 'sounds/sound16.mp3',
    'imags/logo17.png': 'sounds/sound17.mp3',
    'imags/logo18.png': 'sounds/sound18.mp3',
    'imags/logo19.png': 'sounds/sound19.mp3',
    'imags/logo20.png': 'sounds/sound20.mp3',
    'imags/logo21.png': 'sounds/sound-21.mp3',
    
};

        function sliceFruit(fruit) {
    fruit.sliced = true;
    const isBomb = fruit.element.dataset.type === 'bomb';
    const originalSrc = fruit.element.dataset.src;

    // 換成被切開的圖片
    const newSrc = slicedImages[originalSrc];
    fruit.element.querySelector('img').src = newSrc;
    fruit.element.classList.add('sliced');

    // 播放對應音效
    const soundSrc = slicedSounds[originalSrc];
    if (soundSrc) {
        const audio = new Audio(soundSrc);
        audio.play();
    }

    // 更新分數
    if (isBomb) {
        score = Math.max(0, score - 5);
    } else {
        score += 5;
    }
    updateScore();

    // 0.8秒後移除
    setTimeout(() => {
        if (fruit.element.parentNode) {
            fruit.element.remove();
        }
        const index = fruits.indexOf(fruit);
        if (index > -1) fruits.splice(index, 1);
    }, 800);
}
        
        // 更新分數和按鈕狀態
        function updateScore() {
            scoreElement.textContent = score;
            
            // 只有當前分數超過本局最高分數時才更新記錄
            if (score > sessionHighScore) {
                sessionHighScore = score;
                
                // 如果本局最高分數超過歷史最高分數，更新歷史記錄
                if (sessionHighScore > highScore) {
                    highScore = sessionHighScore;
                    highScoreElement.textContent = highScore;
                    localStorage.setItem('fruitNinjaHighScore', highScore);
                }
            }
            
            // 更新按鈕狀態
            document.getElementById('specialBtn').disabled = score < 10;
            document.getElementById('blueBtn').disabled = score < 20;
            document.getElementById('redBtn').disabled = score < 50;
        }
        
        // 特殊水果修正：images/
const specialFruitMap = {
  'imags/logo1.png': { after: 'imags/logo1.jpg', sound: 'sounds/sound1.mp3' },
  'imags/logo2.jpg': { after: 'imags/logo2.jpg',  sound: 'sounds/sound2.mp3' },
  'imags/logo4.png': { after: 'imags/logo4.png', sound: 'sounds/sound4.mp3' },
  'imags/logo5.png': { after: 'imags/logo5.png', sound: 'sounds/sound5.mp3' },
  'imags/logo6.png': { after: 'imags/logo6.png', sound: 'sounds/sound6.mp3' },
  'imags/logo7.png':{ after: 'imags/logo7.png',sound: 'sounds/sound7.mp3' },


  'imags/logo21.png':{ after: 'imags/logo21.png',sound: 'sounds/sound21.mp3' },
};

// 可選：簡單音效快取
const audioCache = new Map();
function playSfx(path){
  let a = audioCache.get(path);
  if(!a){ a = new Audio(path); audioCache.set(path, a); }
  // 重新播放（有些瀏覽器需 cloneNode 才能同時重播）
  a.currentTime = 0; a.play().catch(()=>{ /* 靜默失敗 */ });
}

function spawnSpecialFruit(){
  if (score < 10) return;
  score -= 10; updateScore();

  const keys = Object.keys(specialFruitMap);
  const originalImg = keys[(Math.random()*keys.length)|0];
  const fruitInfo = specialFruitMap[originalImg];

  const specialFruit = document.createElement('div');
  specialFruit.className = 'special-fruit';
  const img = document.createElement('img');
  img.src = originalImg; img.className = 'fruit-img';
  specialFruit.appendChild(img);

  // 動態取得寬高
  const size = 60;
  specialFruit.style.left = Math.max(0, Math.random()*(gameArea.offsetWidth  - size)) + 'px';
  specialFruit.style.top  = Math.max(0, Math.random()*(gameArea.offsetHeight - size)) + 'px';

  gameArea.appendChild(specialFruit);
  specialFruits.push(specialFruit);

  let cooling = false;
  const handleTouch = () => {
    if (cooling) return;
    cooling = true;

    specialFruit.classList.remove('touched');
    void specialFruit.offsetWidth;
    specialFruit.classList.add('touched');

    img.src = fruitInfo.after;
    playSfx(fruitInfo.sound);

    setTimeout(() => {
      img.src = originalImg;
      specialFruit.classList.remove('touched');
      cooling = false;
    }, 800);
  };
const isMobile = window.matchMedia('(max-width: 480px)').matches;

if (isMobile) {
 let isDragging = false;
let dragOffsetX = 0, dragOffsetY = 0;
let startX = 0, startY = 0;
const TAP_THRESHOLD = 5;

// 新增：拖曳過程是否已觸發過 handleTouch（避免連發）
let playedDuringDrag = false;
const DRAG_TRIGGER = 6; // 超過 6px 視為開始拖曳

specialFruit.addEventListener('pointerdown', (e) => {
  e.preventDefault(); e.stopPropagation();
  isDragging = true;
  startX = e.clientX; startY = e.clientY;

  playedDuringDrag = false; // 每次按下重置

  specialFruit.setPointerCapture?.(e.pointerId);

  const rect = specialFruit.getBoundingClientRect();
  dragOffsetX = e.clientX - rect.left;
  dragOffsetY = e.clientY - rect.top;
  specialFruit.style.zIndex = 1000;
});

specialFruit.addEventListener('pointermove', (e) => {
  if (!isDragging || !specialFruit.parentNode) return;
  e.preventDefault();

  const gameRect = gameArea.getBoundingClientRect();
  const w = specialFruit.offsetWidth  || 60;
  const h = specialFruit.offsetHeight || 60;

  let x = e.clientX - gameRect.left - dragOffsetX;
  let y = e.clientY - gameRect.top  - dragOffsetY;

  const maxX = Math.max(0, gameArea.clientWidth  - w);
  const maxY = Math.max(0, gameArea.clientHeight - h);

  x = Math.max(0, Math.min(x, maxX));
  y = Math.max(0, Math.min(y, maxY));

  specialFruit.style.left = x + 'px';
  specialFruit.style.top  = y + 'px';

  // 拖曳超過門檻 → 觸發一次音效/變身
  if (!playedDuringDrag &&
      (Math.abs(e.clientX - startX) > DRAG_TRIGGER ||
       Math.abs(e.clientY - startY) > DRAG_TRIGGER)) {
    playedDuringDrag = true;
    handleTouch(); // 冷卻由 handleTouch 內的 cooling 控制
  }
});

const endDrag = (e) => {
  if (!isDragging) return;
  e.preventDefault();

  const isTap =
    Math.abs(e.clientX - startX) < TAP_THRESHOLD &&
    Math.abs(e.clientY - startY) < TAP_THRESHOLD;

  isDragging = false;
  specialFruit.style.zIndex = 90;
  try { specialFruit.releasePointerCapture?.(e.pointerId); } catch {}

  // 若是點擊而非拖曳，這裡再補一次觸發
  if (isTap && !playedDuringDrag) {
    handleTouch();
  }
};

specialFruit.addEventListener('pointerup', endDrag);
specialFruit.addEventListener('pointercancel', endDrag);

} else {
  // ===== 桌機：沿用你原本的寫法（保留）======
  specialFruit.addEventListener('click',      (e)=>{ e.stopPropagation(); handleTouch(); }, {passive:true});
  specialFruit.addEventListener('touchstart', (e)=>{ e.stopPropagation(); handleTouch(); }, {passive:true});

  let isDragging=false, dragOffsetX=0, dragOffsetY=0;
  specialFruit.addEventListener('mousedown', (e)=>{
    e.preventDefault(); e.stopPropagation();
    isDragging=true;
    const rect=specialFruit.getBoundingClientRect();
    dragOffsetX = e.clientX - rect.left;
    dragOffsetY = e.clientY - rect.top;
    specialFruit.style.zIndex=1000;
    handleTouch();
  });

  const onMove=(e)=>{
    if(!isDragging || !specialFruit.parentNode) return;
    const gameRect = gameArea.getBoundingClientRect();
    const clientX = e.clientX ?? (e.touches && e.touches[0].clientX);
    const clientY = e.clientY ?? (e.touches && e.touches[0].clientY);
    if(clientX==null) return;

    const w = specialFruit.offsetWidth  || 60;
    const h = specialFruit.offsetHeight || 60;

    let x = clientX - gameRect.left - dragOffsetX;
    let y = clientY - gameRect.top  - dragOffsetY;
    x = Math.max(0, Math.min(x, gameArea.offsetWidth  - w));
    y = Math.max(0, Math.min(y, gameArea.offsetHeight - h));
    specialFruit.style.left = x + 'px';
    specialFruit.style.top  = y + 'px';
  };

  const endDrag=()=>{ if(isDragging){ isDragging=false; specialFruit.style.zIndex=90; } };

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup',   endDrag, {once:false});
  document.addEventListener('touchmove', onMove,  {passive:false});
  document.addEventListener('touchend',  endDrag, {once:false});
}
}


// 藍色按鈕專用 → { 換背景 }
const blueBackgroundsDesktop = [
  
  'imags/pcbg1.jpg',
  'imags/pcbg2.jpg',
  'imags/pcbg3.jpg',
  'imags/pcbg4.jpg',
  'imags/pcbg5.jpg',
  'imags/pcbg6.jpg',
  'imags/pcbg7.jpg',
  'imags/pcbg8.jpg',
  'imags/pcbg9.jpg',
  'imags/pcbg10.jpg',
  'imags/pcbg11.jpg',
  'imags/pcbg12.jpg',
  'imags/pcbg13.jpg',
  'imags/pcbg14.jpg',
  'imags/pcbg15.jpg',
  'imags/pcbg16.jpg',
  'imags/pcbg17.jpg',
  'imags/pcbg18.jpg',
  'imags/pcbg19.jpg',
  'imags/pcbg20.jpg',
  'imags/pcbg21.jpg',
  'imags/pcbg22.jpg',
  'imags/pcbg23.jpg',
  'imags/pcbg24.jpg',
  'imags/pcbg25.jpg',



  
];

// 手機（≤450px）用背景
const blueBackgroundsMobile = [
  'imags/bg1.jpg',
 
  'imags/bg4.jpg',
  'imags/bg5.jpg',
  'imags/bg6.jpg',
  'imags/bg7.jpg',
  'imags/bg8.jpg',
  'imags/bg9.jpg',
  'imags/bg10.jpg',
  'imags/bg11.jpg',
  'imags/bg12.jpg',
  'imags/bg13.jpg',
  'imags/bg14.jpg',
  'imags/bg15.jpg',
  'imags/bg16.jpg',
  'imags/bg17.jpg',
  'imags/bg18.jpg',
  'imags/bg19.jpg',
  'imags/bg20.jpg',
  'imags/bg21.jpg',
  'imags/bg22.jpg',
  'imags/bg23.jpg',
  'imags/bg24.jpg',
  'imags/bg25.jpg',
  
  // …放你想給手機用的圖
];
// 取得當前應用的背景清單
function getBlueBackgrounds() {
  return window.matchMedia('(max-width: 450px)').matches
    ? blueBackgroundsMobile
    : blueBackgroundsDesktop;
}

function changeBackgroundRandomBlue() {
  if (score < 20) return; // 按鈕消耗 20 分
  score -= 20;
  updateScore();

  const list = getBlueBackgrounds();
  if (!list.length) return;

  const randomImg = list[Math.floor(Math.random() * list.length)];
  gameArea.style.backgroundImage = `url(${randomImg})`;
  gameArea.style.backgroundSize = 'cover';
  gameArea.style.backgroundPosition = 'center';
}



// 高級圖片專用 → { after: 變身圖片, sound: 對應音效 }
const redEffectMap = {
  'imags/sp logo1.png': { after: 'imags/sp logo1.png', sound: 'sounds/sound1.mp3' },
  'imags/sp logo2.png': { after: 'imags/sp logo2.png', sound: 'sounds/sound1.mp3' },
  'imags/sp logo3.png': { after: 'imags/sp logo3.png', sound: 'sounds/sound1.mp3' },
  'imags/sp logo4.png': { after: 'imags/sp logo4.png', sound: 'sounds/sound1.mp3' },
  'imags/sp logo5.png': { after: 'imags/sp logo5.png', sound: 'sounds/sound1.mp3' },
  'imags/sp logo6.png': { after: 'imags/sp logo6.png', sound: 'sounds/sound1.mp3' },
  'imags/sp logo7.png': { after: 'imags/sp logo7.png', sound: 'sounds/sound1.mp3' },
  

  
};
        
function spawnRedEffect() {
  if (score < 50) return; // 按鈕消耗 50 分
  score -= 50;
  updateScore();

  // 隨機挑一張
  const keys = Object.keys(redEffectMap);
  const originalImg = keys[Math.floor(Math.random() * keys.length)];
  const effectInfo = redEffectMap[originalImg]; // after + sound

  const effectDiv = document.createElement('div');
  effectDiv.className = 'special-red';

  // 加圖片
  const img = document.createElement('img');
  img.src = originalImg;
  img.className = 'fruit-img';
  effectDiv.appendChild(img);

  // 隨機位置
  const baseSize = 60;
  effectDiv.style.left = Math.max(0, Math.random() * (gameArea.offsetWidth  - baseSize)) + 'px';
  effectDiv.style.top  = Math.max(0, Math.random() * (gameArea.offsetHeight - baseSize)) + 'px';

  gameArea.appendChild(effectDiv);

  // 觸發：換圖 + 音效 + 回原圖（含冷卻）
  let cooling = false;
  const handleTouch = () => {
    if (cooling) return;
    cooling = true;

    effectDiv.classList.remove('touched');
    void effectDiv.offsetWidth;          // 重新觸發 CSS 動畫
    effectDiv.classList.add('touched');

    img.src = effectInfo.after;
    playSfx(effectInfo.sound);           // 🔁 用快取音效

    setTimeout(() => {
      img.src = originalImg;
      effectDiv.classList.remove('touched');
      cooling = false;
    }, 800);
  };

  // —— 依螢幕寬度選事件模型：≤480 用 Pointer，其他用原本桌機滑鼠 ——
  const isMobile = window.matchMedia('(max-width: 480px)').matches;

  if (isMobile) {
    // ===== 手機/小螢幕：Pointer Events =====
    let isDragging = false;
let dragOffsetX = 0, dragOffsetY = 0;
let startX = 0, startY = 0;
const TAP_THRESHOLD = 5;

// ✅ 新增：拖曳時是否已觸發過音效/變身
let playedDuringDrag = false;
const DRAG_TRIGGER = 6; // 超過 6px 視為開始拖曳

effectDiv.addEventListener('pointerdown', (e) => {
  e.preventDefault(); e.stopPropagation();
  isDragging = true;
  startX = e.clientX; startY = e.clientY;

  playedDuringDrag = false;      // ✅ 每次新按下就重置

  effectDiv.setPointerCapture?.(e.pointerId);

  const rect = effectDiv.getBoundingClientRect();
  dragOffsetX = e.clientX - rect.left;
  dragOffsetY = e.clientY - rect.top;
  effectDiv.style.zIndex = 1000;
});

effectDiv.addEventListener('pointermove', (e) => {
  if (!isDragging || !effectDiv.parentNode) return;
  e.preventDefault();

  const gameRect = gameArea.getBoundingClientRect();
  const w = effectDiv.offsetWidth  || baseSize;
  const h = effectDiv.offsetHeight || baseSize;

  let x = e.clientX - gameRect.left - dragOffsetX;
  let y = e.clientY - gameRect.top  - dragOffsetY;

  const maxX = Math.max(0, gameArea.clientWidth  - w);
  const maxY = Math.max(0, gameArea.clientHeight - h);

  x = Math.max(0, Math.min(x, maxX));
  y = Math.max(0, Math.min(y, maxY));

  effectDiv.style.left = x + 'px';
  effectDiv.style.top  = y + 'px';

  // ✅ 新增：拖曳超過門檻，觸發一次音效/變身
  if (!playedDuringDrag &&
      (Math.abs(e.clientX - startX) > DRAG_TRIGGER ||
       Math.abs(e.clientY - startY) > DRAG_TRIGGER)) {
    playedDuringDrag = true;
    handleTouch(); // 冷卻機制已在 handleTouch 內處理
  }
});

const endDrag = (e) => {
  if (!isDragging) return;
  e.preventDefault();

  const isTap =
    Math.abs(e.clientX - startX) < TAP_THRESHOLD &&
    Math.abs(e.clientY - startY) < TAP_THRESHOLD;

  isDragging = false;
  effectDiv.style.zIndex = 90;
  try { effectDiv.releasePointerCapture?.(e.pointerId); } catch {}

  // 點擊才在這裡觸發；若拖曳時已觸發過，就不再播
  if (isTap && !playedDuringDrag) {
    handleTouch();
  }
};

effectDiv.addEventListener('pointerup', endDrag);
effectDiv.addEventListener('pointercancel', endDrag);
  } else {
    // ===== 桌機：沿用你原本的滑鼠事件 =====
    // 點擊/觸控（沿用舊邏輯）
    effectDiv.addEventListener('click',      (e) => { e.stopPropagation(); handleTouch(); }, { passive: true });
    effectDiv.addEventListener('touchstart', (e) => { e.stopPropagation(); handleTouch(); }, { passive: true });

    // 拖曳
    let isDragging = false;
    let dragOffsetX = 0, dragOffsetY = 0;

    effectDiv.addEventListener('mousedown', (e) => {
      e.preventDefault(); e.stopPropagation();
      isDragging = true;
      const rect = effectDiv.getBoundingClientRect();
      dragOffsetX = e.clientX - rect.left;
      dragOffsetY = e.clientY - rect.top;
      effectDiv.style.zIndex = 1000;
      handleTouch(); // 若你希望拖曳開始就有特效，保留這行
    });

    const onMove = (e) => {
      if (!isDragging || !effectDiv.parentNode) return;
      e.preventDefault();
      const gameRect = gameArea.getBoundingClientRect();

      const w = effectDiv.offsetWidth  || baseSize;
      const h = effectDiv.offsetHeight || baseSize;

      let x = e.clientX - gameRect.left - dragOffsetX;
      let y = e.clientY - gameRect.top  - dragOffsetY;
      x = Math.max(0, Math.min(x, gameArea.offsetWidth  - w));
      y = Math.max(0, Math.min(y, gameArea.offsetHeight - h));
      effectDiv.style.left = x + 'px';
      effectDiv.style.top  = y + 'px';
      
    };

    const endDrag = () => {
      if (isDragging) {
        isDragging = false;
        effectDiv.style.zIndex = 90;
      }
    };

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup',   endDrag, { once: false });
    document.addEventListener('touchmove', onMove,  { passive: false });
    document.addEventListener('touchend',  endDrag, { once: false });
  }
}


const playlist = [
  { title: 'friends forever', src: 'sounds/song1.mp3' },
  { title: 'Route 1', src: 'sounds/song2.mp3' },
  { title: 'Pokémon Center', src: 'sounds/song3.mp3' },
];

// ======= 元件抓取 =======
const audio   = document.getElementById('audioPlayer');
audio.loop = true;
const titleEl = document.getElementById('trackTitle');
const btnPrev = document.getElementById('btnPrev');
const btnPlay = document.getElementById('btnPlay');
const btnNext = document.getElementById('btnNext');
const iconPlay  = document.getElementById('iconPlay');
const iconPause = document.getElementById('iconPause');

let current = 0;

// ======= 載入/更新 =======
function loadTrack(i){
  current = (i + playlist.length) % playlist.length;
  const track = playlist[current];
  audio.src = track.src;
  titleEl.textContent = track.title || '未命名';
}

function next(){ loadTrack(current+1); play(); }
function prev(){ loadTrack(current-1); play(); }

function play(){
  audio.play().then(()=>{
    iconPlay.style.display = 'none';
    iconPause.style.display = '';
  }).catch(()=>{/* 自動播放被瀏覽器阻擋就保持暫停狀態 */});
}

function pause(){
  audio.pause();
  iconPlay.style.display = '';
  iconPause.style.display = 'none';
}

function toggle(){
  if (audio.paused) play(); else pause();
}

function next(){ loadTrack(current+1); play(); }
function prev(){ loadTrack(current-1); play(); }

// ======= 綁事件 =======
btnPlay.addEventListener('click', toggle);
btnNext.addEventListener('click', next);
btnPrev.addEventListener('click', prev);


// 初始載入第一首（不自動播放）
loadTrack(0);
pause();


// 建立偵測器元素
const statsPanel = document.createElement("div");
statsPanel.style.position = "fixed";
statsPanel.style.bottom = "10px";
statsPanel.style.left = "10px";
statsPanel.style.background = "rgba(0,0,0,0.6)";
statsPanel.style.color = "#0f0";
statsPanel.style.fontSize = "14px";
statsPanel.style.padding = "5px 10px";
statsPanel.style.borderRadius = "6px";
statsPanel.style.fontFamily = "monospace";
statsPanel.style.zIndex = "9999";
document.body.appendChild(statsPanel);

// FPS 計算
let lastTime = performance.now();
let frameCount = 0;
let fps = 0;

function updateStats() {
    const now = performance.now();
    frameCount++;

    if (now - lastTime >= 1000) { // 每秒更新一次 FPS
        fps = frameCount;
        frameCount = 0;
        lastTime = now;
    }

    // 顯示 FPS 與場上水果數量
    statsPanel.textContent = `FPS: ${fps} | Fruits: ${fruits.length}`;
    
    requestAnimationFrame(updateStats);
}

// 啟動監測
updateStats();


        // 暫停/繼續
        function togglePause() {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? 'start (開始)' : 'stop (暫停)';
        }
        
        // 重新開始
function restartGame() {
    score = 0;
    sessionHighScore = 0; // 重置本局最高分數
    isPaused = false;
    updateScore();
    pauseBtn.textContent = 'stop (暫停)';

    // 清除所有水果和特殊效果
    fruits.forEach(fruit => fruit.element.remove());
    specialFruits.forEach(fruit => fruit.remove());
    sliceLines.forEach(line => line.remove());

    // ✅ 新增：清除所有 .special-red 圖案
    document.querySelectorAll('.special-red').forEach(el => el.remove());

    // 清空陣列
    fruits = [];
    specialFruits = [];
    sliceLines = [];

    // 重置背景
    document.body.className = '';
    gameArea.className = 'game-area';
}
        
        // 事件監聽器
        gameArea.addEventListener('mousedown', startSlice);
        gameArea.addEventListener('mousemove', slice);
        gameArea.addEventListener('mouseup', endSlice);
        
        gameArea.addEventListener('touchstart', startSlice, { passive: false });
        gameArea.addEventListener('touchmove', slice, { passive: false });
        gameArea.addEventListener('touchend', endSlice);
        
        // 遊戲主循環
        setInterval(() => {
            if (Math.random() < 0.02) { // 2% 機率每幀生成水果
                spawnFruit();
            }
            updateFruits();
        }, 16); // ~60 FPS
    </script>
    <script>
    function toggleDrawer(btn){
      const collapsed = document.body.classList.toggle('drawer-collapsed');
      btn.textContent = collapsed ? '⬇' : '⬆';
      btn.setAttribute('aria-expanded', String(!collapsed));
    }
  </script>
  <div class="credit">感謝 黃韋傑學者 提供</div>
</body>

</html>